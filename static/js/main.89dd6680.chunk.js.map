{"version":3,"sources":["../../src/utils.js","../../src/DebugOffset.js","../../src/Scrollama.js","../../src/Step.js","index.js"],"names":["markerStyles","position","left","width","height","borderTop","zIndex","offsetTextStyles","fontSize","fontFamily","margin","padding","DebugOffset","offsetMargin","offsetVal","style","top","OBSERVER_NAMES","Scrollama","stepEnter","stepExit","stepProgress","name","o","window","innerHeight","id","step","body","document","html","Math","getPageHeight","viewH","enable","console","marginTop","marginBottom","options","rootMargin","obs","IntersectionObserver","threshold","entry","isIntersecting","bottom","topAdjusted","bottomAdjusted","intersectionRatio","count","t","ratio","i","progress","resp","element","data","direction","children","prefix","onStepEnter","onStepExit","onStepProgress","offset","debug","React","childId","isNaN","this","domDidLoad","bind","isDebug","state","props","ref","Component","PropTypes","func","Step","offsetHeight","nodeRef","Graphic","steps","backgroundColor","setState","classes","className","navbar","href","pageTitle","pageSubtitle","graphicContainer","scroller","map","value","key","round","graphic","PureComponent","StyledGraphic","injectSheet","display","right","color","textAlign","justifyContent","flexBasis","alignSelf","paddingTop","paddingBottom","border","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.89dd6680.chunk.js","sourcesContent":["export const getPageHeight = () => {\n  const body = document.body;\n  const html = document.documentElement;\n\n  return Math.max(\n    body.scrollHeight,\n    body.offsetHeight,\n    html.clientHeight,\n    html.scrollHeight,\n    html.offsetHeight,\n  );\n};\n","import React from 'react';\n\n// Since these styles are the only styles in the library, I opted to use inline\n// styling to maintain dependency independence\nconst markerStyles = {\n  position: 'fixed',\n  left: 0,\n  width: '100%',\n  height: 0,\n  borderTop: '2px dashed black',\n  zIndex: 9999,\n};\nconst offsetTextStyles = {\n  fontSize: '12px',\n  fontFamily: 'monospace',\n  margin: 0,\n  padding: 6,\n};\n\nconst DebugOffset = ({ offsetMargin, offsetVal }) => (\n  <div style={{ ...markerStyles, top: offsetMargin }}>\n    <p style={offsetTextStyles}>trigger: {offsetVal}</p>\n  </div>\n);\n\nexport default DebugOffset;\n","import React, { Component, Fragment } from 'react';\nimport PropTypes from 'prop-types';\nimport { getPageHeight } from './utils';\nimport DebugOffset from './DebugOffset';\n\nconst OBSERVER_NAMES = [\n  'stepAbove',\n  'stepBelow',\n  'stepProgress',\n  'viewportAbove',\n  'viewportBelow',\n];\n\nclass Scrollama extends Component {\n  // step trigger callbacks\n  cb = {\n    stepEnter: () => null,\n    stepExit: () => null,\n    stepProgress: () => null,\n  };\n\n  // intersection observers\n  io = {};\n\n  // disconnects all observers of a certain function\n  disconnectObserver = name =>\n    this.io[name] && this.io[name].forEach(o => o.disconnect());\n\n  // stores step elements by id\n  stepElIds = [];\n\n  viewH = window.innerHeight;\n  pageH = 0;\n  offsetVal = 0;\n  offsetMargin = 0;\n  previousYOffset = 0;\n  progressThreshold = 0;\n\n  direction = 'down';\n\n  updateDirection = () => {\n    if (window.pageYOffset > this.previousYOffset) {\n      this.direction = 'down';\n    } else if (window.pageYOffset < this.previousYOffset) {\n      this.direction = 'up';\n    }\n    this.previousYOffset = window.pageYOffset;\n  };\n\n  isReady = false;\n  isEnabled = false;\n  isDebug = false;\n\n  progressMode = false;\n\n  constructor(props) {\n    super(props);\n    const {\n      children,\n      prefix,\n      onStepEnter,\n      onStepExit,\n      onStepProgress,\n      offset,\n      progress,\n      threshold,\n      debug,\n    } = this.props;\n\n    React.Children.forEach(children, (child, idx) => {\n      const childId = `scrollama-${prefix ? prefix + '-' : ''}${idx}`;\n      this[childId] = React.createRef();\n      this.stepElIds.push(childId);\n    });\n\n    if (offset && !isNaN(offset))\n      this.offsetVal = Math.min(Math.max(0, offset), 1);\n\n    this.cb.stepEnter = onStepEnter;\n    this.cb.stepExit = onStepExit;\n    this.cb.stepProgress = onStepProgress;\n\n    this.isDebug = debug;\n    this.progressMode = progress;\n    this.progressThreshold = Math.max(1, +threshold);\n\n    this.isReady = true;\n\n    // offsetMargin stored in state because it's the only property that is\n    // changed after Scrollama's construction and may be rendered (<DebugOffset/>'s\n    // position depends on it)\n    this.state = {\n      offsetMargin: this.offsetVal * this.viewH,\n    };\n  }\n\n  componentDidMount() {\n    window.addEventListener('load', this.domDidLoad.bind(this));\n  }\n\n  domDidLoad() {\n    this.handleResize();\n    this.handleEnable(true);\n    window.addEventListener('resize', this.handleResize);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('load', this.domDidLoad.bind(this));\n    window.removeEventListener('resize', this.handleResize);\n    this.handleEnable(false);\n  }\n\n  getStep = id => {\n    const step = this[id];\n    if (step && step.current) {\n      return step.current;\n    }\n    throw 'Could not get step with id ' + id;\n  };\n\n  handleResize = () => {\n    this.viewH = window.innerHeight;\n    this.pageH = getPageHeight();\n    this.setState({ offsetMargin: this.offsetVal * this.viewH });\n\n    if (this.isReady) {\n      // recalculate offset heights for each step\n      this.stepElIds.forEach(id => {\n        const step = this.getStep(id);\n        step.updateOffsetHeight();\n      });\n      if (this.isEnabled) this.updateIO();\n    }\n  };\n\n  handleEnable = enable => {\n    if (enable && !this.isEnabled) {\n      if (this.isReady) {\n        this.updateIO();\n      } else {\n        console.error(\n          'react scrollama: handleEnable() called before scroller was ready',\n        );\n        this.isEnabled = false;\n        return;\n      }\n    }\n    if (!enable && this.isEnabled) {\n      OBSERVER_NAMES.forEach(this.disconnectObserver);\n    }\n    this.isEnabled = enable;\n  };\n\n  // Recreate all intersection observers\n  updateIO = () => {\n    OBSERVER_NAMES.forEach(this.disconnectObserver);\n    this.updateStepAboveIO();\n    this.updateStepBelowIO();\n\n    if (this.progressMode) this.updateStepProgressIO();\n  };\n\n  /* INTERSECTION OBSERVER CREATORS */\n\n  // Create observers for intersections above steps\n  updateStepAboveIO = () => {\n    const { offsetMargin } = this.state;\n    this.io.stepAbove = this.stepElIds.map(id => {\n      const step = this.getStep(id);\n      const marginTop = -offsetMargin + step.state.offsetHeight;\n      const marginBottom = offsetMargin - this.viewH;\n      const options = {\n        rootMargin: `${marginTop}px 0px ${marginBottom}px 0px`,\n      };\n\n      const obs = new IntersectionObserver(this.intersectStepAbove, options);\n      obs.observe(step.getDOMNode());\n      return obs;\n    });\n  };\n\n  // Create observers for intersections below steps\n  updateStepBelowIO = () => {\n    const { offsetMargin } = this.state;\n    this.io.stepBelow = this.stepElIds.map(id => {\n      const step = this.getStep(id);\n      const marginTop = -offsetMargin;\n      const marginBottom = offsetMargin - this.viewH + step.state.offsetHeight;\n      const options = {\n        rootMargin: `${marginTop}px 0px ${marginBottom}px 0px`,\n      };\n\n      const obs = new IntersectionObserver(this.intersectStepBelow, options);\n      obs.observe(step.getDOMNode());\n      return obs;\n    });\n  };\n\n  // Create observers for progress\n  updateStepProgressIO = () => {\n    const { offsetMargin } = this.state;\n    this.io.stepProgress = this.stepElIds.map(id => {\n      const step = this.getStep(id);\n      const marginTop = -offsetMargin + step.state.offsetHeight;\n      const marginBottom = offsetMargin - this.viewH;\n      const options = {\n        rootMargin: `${marginTop}px 0px ${marginBottom}px 0px`,\n        threshold: this.createThreshold(step.state.offsetHeight),\n      };\n\n      const obs = new IntersectionObserver(this.intersectStepProgress, options);\n      obs.observe(step.getDOMNode());\n      return obs;\n    });\n  };\n\n  /* INTERSECTION OBSERVER HANDLERS */\n\n  // Handles scrolling down and entering or scrolling up and leaving a step\n  intersectStepAbove = ([entry]) => {\n    this.updateDirection();\n    const { offsetMargin } = this.state;\n    const {\n      isIntersecting,\n      boundingClientRect: { top, bottom },\n      target: { id },\n    } = entry;\n\n    const topAdjusted = top - offsetMargin;\n    const bottomAdjusted = bottom - offsetMargin;\n\n    const step = this.getStep(id);\n\n    if (\n      isIntersecting &&\n      topAdjusted <= 0 &&\n      bottomAdjusted >= 0 &&\n      this.direction === 'down' &&\n      step.state.state !== 'enter'\n    )\n      this.notifyStepEnter(step, this.direction);\n\n    // Exiting from above means not intersecting and topAdjusted is positive\n    if (\n      !isIntersecting &&\n      // Should be >0, but >-0.05 fixes a weird floating point issue in Chrome.\n      // The exact –ε is different for every this.prop.offset. Very sad folks.\n      topAdjusted > -0.5 &&\n      this.direction === 'up' &&\n      step.state.state === 'enter'\n    )\n      this.notifyStepExit(step, this.direction);\n  };\n\n  // Handles scrolling up and entering or scrolling down and leaving a step\n  intersectStepBelow = ([entry]) => {\n    this.updateDirection();\n    const { offsetMargin } = this.state;\n    const {\n      isIntersecting,\n      boundingClientRect: { top, bottom },\n      target: { id },\n    } = entry;\n\n    const topAdjusted = top - offsetMargin;\n    const bottomAdjusted = bottom - offsetMargin;\n\n    const step = this.getStep(id);\n\n    if (\n      isIntersecting &&\n      topAdjusted <= 0 &&\n      bottomAdjusted >= 0 &&\n      this.direction === 'up' &&\n      step.state.state !== 'enter'\n    )\n      this.notifyStepEnter(step, this.direction);\n\n    if (\n      !isIntersecting &&\n      bottomAdjusted < 0 &&\n      this.direction === 'down' &&\n      step.state.state === 'enter'\n    )\n      this.notifyStepExit(step, this.direction);\n  };\n\n  intersectStepProgress = ([entry]) => {\n    this.updateDirection();\n    const {\n      isIntersecting,\n      intersectionRatio,\n      boundingClientRect: { bottom },\n      target: { id },\n    } = entry;\n\n    const bottomAdjusted = bottom - this.state.offsetMargin;\n    if (isIntersecting && bottomAdjusted >= 0)\n      this.notifyStepProgress(this.getStep(id), intersectionRatio);\n  };\n\n  createThreshold = height => {\n    const count = Math.ceil(height / this.progressThreshold);\n    const t = [];\n    const ratio = 1 / count;\n    for (let i = 0; i <= count; i += 1) {\n      t.push(i * ratio);\n    }\n    return t;\n  };\n\n  /* NOTIFY CALLBACKS */\n\n  notifyStepProgress = (step, progress) => {\n    if (progress !== undefined) step.progress(progress);\n\n    const resp = {\n      element: step.getDOMNode(),\n      data: step.getData(),\n      progress: step.state.progress,\n    };\n    if (step.state.state === 'enter') this.cb.stepProgress(resp);\n  };\n\n  notifyStepEnter = (step, direction) => {\n    step.enter(direction);\n\n    const resp = {\n      element: step.getDOMNode(),\n      data: step.getData(),\n      direction,\n    };\n    if (this.cb.stepEnter) this.cb.stepEnter(resp);\n\n    if (this.progressMode) this.notifyStepProgress(step);\n  };\n\n  notifyStepExit = (step, direction) => {\n    if (this.progressMode) {\n      if (direction === 'down' && step.state.progress < 1)\n        this.notifyStepProgress(step, 1);\n      if (direction === 'up' && step.state.progress > 0)\n        this.notifyStepProgress(step, 0);\n    }\n    step.exit(direction);\n\n    const resp = {\n      element: step.getDOMNode(),\n      data: step.getData(),\n      direction,\n    };\n    if (this.cb.stepExit) this.cb.stepExit(resp);\n  };\n\n  render() {\n    return (\n      <Fragment>\n        {this.isDebug && (\n          <DebugOffset\n            offsetMargin={this.state.offsetMargin}\n            offsetVal={this.offsetVal}\n          />\n        )}\n        {React.Children.map(this.props.children, (child, index) => {\n          const id = this.stepElIds[index];\n          return React.cloneElement(child, {\n            id,\n            ref: this[id],\n          });\n        })}\n      </Fragment>\n    );\n  }\n}\n\nScrollama.defaultProps = {\n  offset: 0.33,\n  progress: false,\n  threshold: 4,\n};\n\nScrollama.propTypes = {\n  offsetVal: PropTypes.number,\n  debug: PropTypes.bool,\n  onStepEnter: PropTypes.func,\n  onStepExit: PropTypes.func,\n  onStepProgress: PropTypes.func,\n};\n\nexport default Scrollama;\n","import React, { Component } from 'react';\n\nclass Step extends Component {\n  state = {\n    direction: null, // 'up' or 'down'\n    state: null, // 'enter' or 'exit'\n    offsetHeight: null,\n    progress: 0,\n  };\n\n  nodeRef = React.createRef();\n\n  getDOMNode = () => this.nodeRef.current;\n\n  getData = () => this.props.data;\n\n  updateOffsetHeight = () =>\n    this.setState({\n      offsetHeight: this.getDOMNode().offsetHeight,\n    });\n\n  enter = direction => this.setState({ state: 'enter', direction });\n  exit = direction => this.setState({ state: 'exit', direction });\n  progress = progress => this.setState({ progress });\n\n  render() {\n    const { id, children } = this.props;\n\n    return React.cloneElement(React.Children.only(children), {\n      // place id on child to retrieve id from the raw DOM node (which\n      // is what the intersection observer gives our callback\n      id,\n\n      // place ref on child to calculate offsets\n      ref: this.nodeRef,\n    });\n  }\n}\n\nexport default Step;\n","import React, { PureComponent } from 'react';\nimport ReactDOM from 'react-dom';\nimport injectSheet from 'react-jss';\nimport { Scrollama, Step } from 'react-scrollama';\n\nconst styles = {\n  navbar: {\n    position: 'fixed',\n    display: 'flex',\n    top: 0,\n    right: 0,\n    zIndex: 1,\n    '& a': {\n      display: 'block',\n      fontFamily: 'Helvetica',\n      fontSize: '20px',\n      color: '#00e',\n      padding: '20px',\n    },\n  },\n  pageTitle: {\n    fontFamily: 'Helvetica',\n    textAlign: 'center',\n    fontSize: '30px',\n    margin: '110px 0 10px',\n    '& a': {\n      color: '#00e',\n    },\n  },\n  pageSubtitle: {\n    margin: 0,\n    fontFamily: 'Helvetica',\n    textAlign: 'center',\n    fontSize: '24px',\n    color: '#888',\n  },\n  graphicContainer: {\n    padding: '40vh 2vw 70vh',\n    display: 'flex',\n    fontFamily: 'Helvetica',\n    justifyContent: 'space-between',\n  },\n  graphic: {\n    flexBasis: '60%',\n    position: 'sticky',\n    width: '100%',\n    padding: '5rem 0',\n    top: '160px',\n    alignSelf: 'flex-start',\n    backgroundColor: '#aaa',\n    '& p': {\n      fontSize: '5rem',\n      textAlign: 'center',\n      color: '#fff',\n    },\n  },\n  scroller: {\n    flexBasis: '35%',\n  },\n  step: {\n    margin: '0 auto 2rem auto',\n    paddingTop: 200,\n    paddingBottom: 200,\n    border: '1px solid #333',\n    '& p': {\n      textAlign: 'center',\n      padding: '1rem',\n      fontSize: '1.5rem',\n    },\n    '&:last-child': {\n      marginBottom: 0,\n    },\n  },\n};\n\nclass Graphic extends PureComponent {\n  state = {\n    data: 0,\n    steps: [10, 20, 30],\n    progress: 0,\n  };\n\n  onStepEnter = ({ element, data }) => {\n    element.style.backgroundColor = 'lightgoldenrodyellow';\n    this.setState({ data });\n  };\n\n  onStepExit = ({ element, direction, data }) => {\n    element.style.backgroundColor = '#fff';\n    if (direction === 'up' && data === this.state.steps[0]) {\n      this.setState({ data: 0 });\n    }\n  };\n\n  onStepProgress = ({ element, progress }) => {\n    this.setState({ progress });\n  };\n\n  render() {\n    const { data, steps, progress } = this.state;\n    const { classes } = this.props;\n\n    return (\n      <div>\n        <div className={classes.navbar}>\n          <a href=\"https://github.com/jsonkao/react-scrollama\">GitHub</a>\n        </div>\n        <p className={classes.pageTitle}>\n          <a href=\"https://github.com/jsonkao/react-scrollama\">React Scrollama</a>\n          {' '}Example\n        </p>\n        <p className={classes.pageSubtitle}>Scroll ↓</p>\n        <div className={classes.graphicContainer}>\n          <div className={classes.scroller}>\n            <Scrollama\n              onStepEnter={this.onStepEnter}\n              onStepExit={this.onStepExit}\n              progress\n              onStepProgress={this.onStepProgress}\n              offset={0.4}\n              debug\n            >\n              {steps.map(value => (\n                <Step data={value} key={value}>\n                  <div className={classes.step}>\n                    <p>step value: {value}</p>\n                    <p>progress: {value === data ? Math.round(progress * 100) : ''}%</p>\n                  </div>\n                </Step>\n              ))}\n            </Scrollama>\n          </div>\n          <div className={classes.graphic}>\n            <p>{data}</p>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nconst StyledGraphic = injectSheet(styles)(Graphic);\n\nReactDOM.render(<StyledGraphic />, document.getElementById('root'));\n"],"sourceRoot":""}